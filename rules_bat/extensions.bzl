_HUB_REPOSITORY_BUILD_TMPL = """\
# Generated by rules_bat. DO NOT EDIT.

package(default_visibility = ["//visibility:public"])

{}
"""

_PKG_ALIAS_TMPL = """\
alias(
    name = "{name}_py",
    actual = "@{repo}//:pkg_py",
)

alias(
    name = "{name}_cc",
    actual = "@{repo}//:pkg_cc",
)
"""

_PKG_REPOSITORY_BUILD_TMPL = """\
# Generated by rules_bat. DO NOT EDIT.

package(default_visibility = ["//visibility:public"])

_PKG_DEPENDENCIES = {dependencies}

_CC_INCLUDES = {cc_includes}
_CC_PATTERNS = ["**/*.h", "**/*.hh", "**/*.hpp", "**/*.hxx"]

cc_library(
    name = "pkg_cc",
    srcs = glob(include = ["**/*.so", "**/*.so.*"], allow_empty = True),
    hdrs = glob(
        include = [
            "{{directory}}/{{pattern}}".format(directory=directory, pattern=pattern)
            for directory in _CC_INCLUDES
            for pattern in _CC_PATTERNS
        ],
        allow_empty = True,
    ),
    includes = _CC_INCLUDES,
    deps = ["@{{dep}}//:pkg_cc".format(dep=dep) for dep in _PKG_DEPENDENCIES],
)

_PY_IMPORTS = {py_imports}
_PY_PATTERNS = ["**/*"]

py_library(
    name = "pkg_py",
    data = glob(
        include = [
            "{{directory}}/{{pattern}}".format(directory=directory, pattern=pattern)
            for directory in _PY_IMPORTS
            for pattern in _PY_PATTERNS
        ],
        allow_empty = True,
    ),
    imports = _PY_IMPORTS,
    deps = [":pkg_cc"] + ["@{{dep}}//:pkg_py".format(dep=dep) for dep in _PKG_DEPENDENCIES],
)
"""


def _ros_package_repository_impl(repository_ctx):
    """Implementation of the ros_package_repository rule."""

    repository_ctx.download_and_extract(
        url = repository_ctx.attr.url,
        sha256 = repository_ctx.attr.sha256,
        type = ".deb",
    )

    for extension in ["tar", "tar.gz", "tar.xz", "tar.zst", "tar.bz2"]:
        archive = repository_ctx.path("data.{}".format(extension))
        if not archive.exists:
            continue

        repository_ctx.extract(archive)
        repository_ctx.delete(archive)
        break

    # TODO(nahuel): Consider reading .dsv files.
    # https://colcon.readthedocs.io/en/released/developer/environment.html#dsv-files

    # TODO(nahuel): Consider using CMake API to collect build information.
    # https://cmake.org/cmake/help/v3.31/manual/cmake-file-api.7.html#object-kind-codemodel

    py_imports = []
    # See https://ros.org/reps/rep-0122.html#lib
    for py_import in ["opt/ros/humble/local/lib/python3.10/dist-packages", "opt/ros/humble/lib/python3.10/site-packages"]:
        py_import_path = repository_ctx.path(py_import)
        if not py_import_path.exists:
            continue

        py_imports.append(py_import)

    cc_includes = []
    # See https://ros.org/reps/rep-0122.html#include
    for cc_include in ["opt/ros/humble/include"]:
        cc_include_path = repository_ctx.path(cc_include)
        if not cc_include_path.exists:
            continue

        for path in cc_include_path.readdir():
            cc_includes.append("{}/{}".format(cc_include, path.basename))

    repository_ctx.file(
        "BUILD.bazel",
        _PKG_REPOSITORY_BUILD_TMPL.format(
            cc_includes = cc_includes,
            py_imports = py_imports,
            dependencies = repository_ctx.attr.dependencies,
        )
    )


ros_package_repository = repository_rule(
    implementation = _ros_package_repository_impl,
    doc = """\
A rule that creates a package repository with the contents of a downloaded Debian
and autogenerated C++ and Python targets.
""",
    attrs = dict(
        url = attr.string_list(doc = "List of mirror URLs referencing the same file."),
        sha256 = attr.string(doc = "The expected SHA-256 hash of the file downloaded."),
        dependencies = attr.string_list(doc = "List of dependencies for this package."),
    ),
)


def _ros_hub_repository_impl(repository_ctx):
    """Implementation of the ros_hub_repository rule."""

    def format_single_repository_alias(name, keys):
        defs = []

        for key in keys:
            _, _, arch = key.rpartition("_")

            if arch != "amd64":
                # TODO(nahuel): Add support for multiple architectures.
                # See file structure and aliases used in rules_distroless.
                continue

            return _PKG_ALIAS_TMPL.format(name = name, repo = key)

    repository_ctx.file(
        "BUILD.bazel",
        _HUB_REPOSITORY_BUILD_TMPL.format("\n".join(
            [format_single_repository_alias(name, keys) for name, keys in repository_ctx.attr.packages.items()]
        ))
    )


ros_hub_repository = repository_rule(
    implementation = _ros_hub_repository_impl,
    doc = """\
A rule that creates a hub repository with aliases to individual package repositories
created by the ROS extension.
""",
    attrs = dict(
        packages = attr.string_list_dict(
            doc = "Dictionary of package names that have corresponding Bazel repositories.",
        ),
    ),
)


def _ros_impl(module_ctx):
    """Implementation of the ros module extension."""

    seen_hub_names = {}

    root_direct_deps = []
    root_direct_dev_deps = []

    for module in module_ctx.modules:
        for parse in module.tags.parse:
            if parse.name in seen_hub_names:
                fail("Duplicate hub repository name: {}".format(parse.name))

            seen_hub_names[parse.name] = True

            # `module_ctx.modules` grants access to all modules that use this tag
            # across the dependency graph.
            #
            # Bazel provides a way to declare the repositories created by this extension
            # that are direct dependencies of the root module.
            #
            # This can be used by other extensions in the Bazel ecosystem to ensure
            # that the `use_repo` calls in `MODULE.bazel` are correct and up to date.
            if module.is_root:
                if module_ctx.is_dev_dependency(parse):
                    root_direct_dev_deps.append(parse.name)
                else:
                    root_direct_deps.append(parse.name)

            lock = json.decode(module_ctx.read(parse.lock))

            if lock["version"] != 1:
                fail("Unsupported distroless lockfile version: {}".format(lock["version"]))

            include_set = {dep: True for dep in parse.non_ros_deps}

            def is_valid(name):
                """Helper function to determine whether to generate a Bazel repository for a given package."""
                return name.startswith("ros-") or name in include_set

            packages = {}

            for package in lock["packages"]:
                if not is_valid(package["name"]):
                    continue

                ros_package_repository(
                    name = package["key"],
                    url = package["urls"],
                    sha256 = package["sha256"],
                    dependencies = [dep["key"] for dep in package["dependencies"] if is_valid(dep["name"])],
                )

                packages.setdefault(package["name"], default = []).append(package["key"])

            ros_hub_repository(name = parse.name, packages = packages)

    return module_ctx.extension_metadata(
        root_module_direct_deps = root_direct_deps,
        root_module_direct_dev_deps = root_direct_dev_deps,
        # This module extension ensures reproducibility via the rules_distroless lockfile.
        reproducible = True,
    )


_parse_tag = tag_class(
    doc = """\
A tag class that can parse a rules_distroless lockfile, download the contents
of ROS packages, and create Bazel repositories with C++ and Python targets.
""",
    attrs = dict(
        name = attr.string(
            mandatory = True,
            doc = "The name of the hub repository that will reference all ROS packages.",
        ),
        lock = attr.label(
            mandatory = True,
            doc = "The rules_distroless lock file to use for the index.",
        ),
        non_ros_deps = attr.string_list(
            doc = "List of packages that should be parsed in addition to packages that begin with `ros-`",
            # TODO(nahuel): Should we create repositories for all packages (ROS and non-ROS)?
            # (i.e. python3, libsystemd0, liblz4).
        ),
    ),
)

ros = module_extension(
    implementation = _ros_impl,
    doc = "A module extension that provides utilities to generate targets for ROS packages.",
    tag_classes = dict(
        parse = _parse_tag,
    ),
)
